## Highlights

- **Accurate**: complete support for the [Bash 4.3 Brace Expansion][bash] specification (passes all of the Bash brace expansion tests)
- **[fast and performant](#benchmarks)**: not only runs fast, but scales well as patterns increase in complexity (other libs don't)
- **Organized code base**: with parser and compiler that are easy to maintain and update when edge cases crop up.
- **Source map** support
- **Well-tested**: 840+ unit tests with thousands of actual patterns tested. Passes all of the [minimatch][] and [brace-expansion][] unit tests as well.
- **Optimized braces**: By default returns an optimized string that can be used for creating regular expressions for matching. 
- **Expanded braces**: Optionally returns an array (like bash). See a [comparison](#optimized-vs-expanded) between optimized and expanded.

## Usage

The main export is a function that takes a brace `pattern` to expand and an `options` object if necessary.

```js
var braces = require('{%= name %}');
braces(pattern[, options]);
```

**Example**

```js
console.log(braces('a/{x,y,z}/b', {expand: true}));
//=> ['a/x/b', 'a/y/b', 'a/z/b']

console.log(braces('a/{x,y,z}/b'));
//=> ['a/(x|y|z)/b']
```


## Examples

**Sequences**

```js
console.log(braces('{1..3}'));
//=> ['1', '2', '3']

console.log(braces('{a..c}'));
//=> ['a', 'b', 'c']

console.log(braces('foo/{a..c}'));
//=> ['foo/a', 'foo/b', 'foo/c']
```


**Nested**

```js
console.log(braces('a/{x,{1..5},y}/c'));
//=> ['a/x/c', 'a/1/c', 'a/2/c', 'a/3/c', 'a/4/c', 'a/5/c', 'a/y/c']
```

## Features

- [lists](#lists): Expands bash "lists": `a/{b,c}/d` => `['a/b/d', 'a/c/d']`
- [sequences](#sequences): Expands alphabetical or numerical "sequences" (ranges): `{1..3}` => `['1', '2', '3']` 
- [steps](#steps): Supports "steps" or increments: `{2..10..2}` => `['2', '4', '6', '8', '10']`
- [escaping](#escaping)
- [options](#options)


### Lists

```js
braces('a/{foo,bar,baz}/b');
//=> ['a/(foo|bar|baz)/b']

braces('a/{foo,bar,baz}/b', {expand: true});
//=> ['a/foo/b', 'a/bar/b', 'a/baz/b']

braces('{foo,bar,baz}/*.js');
//=> ['foo/*.js', 'bar/*.js', 'baz/*.js']
```


### Sequences

Uses [fill-range](https://github.com/jonschlinkert/fill-range) for to expand sequence operators:

```js
braces('a{1..3}b')
//=> ['a1b', 'a2b', 'a3b']

braces('a{5..8}b')
//=> ['a5b', 'a6b', 'a7b', 'a8b']

braces('a{00..05}b')
//=> ['a00b', 'a01b', 'a02b', 'a03b', 'a04b', 'a05b']

braces('a{01..03}b')
//=> ['a01b', 'a02b', 'a03b']

braces('a{000..005}b')
//=> ['a000b', 'a001b', 'a002b', 'a003b', 'a004b', 'a005b']

braces('a{a..e}b')
//=> ['aab', 'abb', 'acb', 'adb', 'aeb']

braces('a{A..E}b')
//=> ['aAb', 'aBb', 'aCb', 'aDb', 'aEb']
```

Pass a function as the last argument to customize range expansions:

```js
var range = braces('x{a..e}y', function (str, i) {
  return String.fromCharCode(str) + i;
});

console.log(range);
//=> ['xa0y', 'xb1y', 'xc2y', 'xd3y', 'xe4y']
```

See [expand-range][] for additional documentation and to learn about all available range expansion features.

## Options


### options.expand

Type: `Boolean`

Deafault: `undefined`


### options.optimize

Type: `Boolean`

Deafault: `true`

Enabled by default.


### options.nodupes

Type: `Boolean`

Deafault: `true`

Duplicates are removed by default. To keep duplicates, pass `{nodupes: false}` on the options

### options.quantifiers

Type: `Boolean`

Deafault: `undefined`

In regular expressions, quanitifiers may be used to specify how many times a token can be repeated.

For example, the regex `/ab{1,3}c/` will match `a`, then the letter `b`, from `1` to `3` times, then the letter `c`. In other words, `abc`, `abbc` and `abbbc` would all match, but not `ac` or `abbbbc`.

Unfortunately, regex quantifiers happen to share the same syntax as [Bash lists]()

The `quantifiers` option tells braces to detect when [regex quantifiers]() are defined in the given pattern, and not to try to expand them as lists.

**Examples**

```js
var braces = require('braces');
console.log(braces('a/b{1,3}/{x,y,z}'));
//=> [ 'a/b(1|3)/(x|y|z)' ]
console.log(braces('a/b{1,3}/{x,y,z}', {quantifiers: true}));
//=> [ 'a/b{1,3}/(x|y|z)' ]
console.log(braces('a/b{1,3}/{x,y,z}', {quantifiers: true, expand: true}));
//=> [ 'a/b{1,3}/x', 'a/b{1,3}/y', 'a/b{1,3}/z' ]
```

## Optimized vs. Expanded

TODO



## Benchmarks

### Running benchmarks

Install dev dependencies:

```bash
npm i -d && npm benchmark
```

### Latest results

```bash
{%= docs("benchmark/last.md") %}
```

## Why is braces [so fast](#benchmarks)?

**Parser/compiler**

Braces uses a "real" parser and compiler to create a highly optimized regex that is often a fraction of the size of the value produced by [minimatch][] (or rather, the library it uses for [brace-expansion][]).


[bash]: www.gnu.org/software/bash/
[braces]: https://github.com/jonschlinkert/braces
[expand-range]: https://github.com/jonschlinkert/expand-range
[fill-range]: https://github.com/jonschlinkert/fill-range
[micromatch]: https://github.com/jonschlinkert/micromatch
[minimatch]: https://github.com/isaacs/minimatch
